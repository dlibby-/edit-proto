<html>
<head>
<style>
#realinputcontext {
    position:absolute;
    top:20px;
    right:20px;
}
#editview {
    white-space:pre
}

.selection {
    background:blue;
    color:white;
}
</style>
<script src="editcontext.js"></script>
<script>

function assert(condition, message) {
    if (!condition) {
        throw message;
    }
}

class EditableView {
    constructor(editContext, editModel) {
        this.editContext = editContext;
        this.editModel = editModel;

        this.caret = document.createElement('span');
        this.caretOn = true;
        this.caretInterval = -1;
        this.caret.style = "outline:1px solid black";

        this.viewElement = document.createElement('code');
        this.viewElement.appendChild(this.caret);
        this.viewElement.style = "position:relative; white-space:pre; width:300px; height:300px";

        // TODO: Belong on controller?
        this.viewElement.addEventListener("mouseup", (function () {
            console.log("view got mouseup");
            this.editContext.focus();
        }).bind(this));

        editableviewholder.appendChild(this.viewElement);

        this.updateCaret();

        this.updateQueued = false;

        this.caretRange = document.createRange();
    }

    queueUpdate() {
        if (!this.updateQueued) {
            window.requestAnimationFrame((() => {
                this.updateView();

                // Turn caret on while the view is actively being updated
                this.caretOn = true;
                this.updateQueued = false;
            }).bind(this));
            this.updateQueued = true;
        }
    }

    updateView() {
        let html = this.editModel.asHtml();
        if (html !== "") {
            this.viewElement.innerHTML = html;
            if (!this.viewElement.querySelector('.selection')) {
                let positions = this.editModel.getCaretAndParagraph();
                // Multiply paragraph position/index by two to account for the <br> that is inbetween
                // each line
                let currentParagraphTextNode = this.viewElement.childNodes[positions.paragraph*2];
                this.caretRange.setStart(currentParagraphTextNode, positions.caret);
                this.caretRange.setEnd(currentParagraphTextNode, positions.caret);
                this.caretRange.insertNode(this.caret);
            }
        } else {
            this.viewElement.innerHTML = "";
            this.viewElement.appendChild(this.caret);
        }
    }

    updateCaret() {
        if (this.editContext.hasFocus()) {
            this.caret.style.visibility = this.caretOn ? "visible" : "hidden";
            this.caretOn = !this.caretOn;
            if (this.caretInterval === -1) {
                const CARET_UPDATE_MS = 500;
                this.caretInterval = window.setInterval((() => this.updateCaret()).bind(this), CARET_UPDATE_MS);
            }
        } else if (this.caretInterval !== -1) {
            this.caret.style.visibility = "hidden";
            window.clearInterval(this.caretInterval);
            this.caretInterval = -1;
        }
    }
    focus() {
        this.caretOn = true;
        this.updateCaret();
    }

    blur() {
        this.updateCaret();
    }
}

class Selection {
    constructor() {
        this.unposition();
    }

    isPositioned() {
        return (this.paragraphIndex !== -1 && this.offset !== -1);
    }

    unposition() {
        this.paragraphIndex = -1;
        this.offset = -1;
    }

    set(paragraphIndex, offset) {
        this.paragraphIndex = paragraphIndex;
        this.offset = offset;
    }
    equals(other) {
        return (this.paragraphIndex == other.paragraphIndex && this.offset == other.offset);
    }
}

class EditModel {
    constructor(editContext) {
        this.textParagraphs = [];
        this.paragraphIndex = 0;
        this.textParagraphs[this.paragraphIndex] = [];
        this.caretPosition = 0;
        this.desiredCaretPosition = 0;
        this.selectionStart = new Selection();
        this.selectionEnd = new Selection();
        this.CaretMovement = { LEFT:0, RIGHT:1, WORDLEFT:2, WORDRIGHT:3, HOME:4, END:5, UP: 6, DOWN: 7};
    }

    asHtml() {
        let html = "";
        this.textParagraphs.forEach((paragraph, index) => {
            // HACK - empty paragraphs need a text node in order to place the caret
            if (paragraph.length === 0) {
                html += " ";
            }

            let selectionStartOffset = this.selectionStart.paragraphIndex === index ? this.selectionStart.offset : -1;
            let selectionEndOffset = this.selectionEnd.paragraphIndex === index ? this.selectionEnd.offset : -1;
            let offsetRealized = 0;
            if (selectionStartOffset !== -1) {
                // Lay down start selection element
                html += paragraph.slice(0, selectionStartOffset).join('');
                html += "<span class='selection'>";
                offsetRealized = selectionStartOffset;
            }
            if (selectionEndOffset !== -1) {
                html += paragraph.slice(offsetRealized, selectionEndOffset).join('');
                html += "</span>";
                offsetRealized = selectionEndOffset;
            }
            if (offsetRealized != paragraph.length) {
                html += paragraph.slice(offsetRealized, paragraph.length).join('');
            }

            html += "<br>";
        })

        return html;
    }

    updateText(text) {
        this.textParagraphs[this.paragraphIndex].splice(this.caretPosition, 0, text);
        this.caretPosition += text.length;
        this.desiredCaretPosition = this.caretPosition;
    }

    getCaretAndParagraph() {
        return { caret: this.caretPosition, paragraph: this.paragraphIndex };
    }

    currentParagraph() {
        return this.textParagraphs[this.paragraphIndex];
    }

    updateSelection(movement) {
        switch (movement) {
            case this.CaretMovement.LEFT:
                if (!this.selectionStart.isPositioned()) {
                    if (this.caretPosition !== 0) {
                        this.selectionStart.set(this.paragraphIndex, this.caretPosition - 1);
                        this.selectionEnd.set(this.paragraphIndex, this.caretPosition);
                    } else if (this.paragraphIndex > 0) {
                        this.selectionStart.set(this.paragraphIndex - 1, this.textParagraphs[this.paragraphIndex - 1].length);
                        this.selectionEnd.set(this.paragraphIndex, this.caretPosition);
                    }
                } else {
                    assert(this.selectionEnd.isPositioned());
                    if ((this.selectionStart.paragraphIndex === this.paragraphIndex)
                        && (this.selectionStart.offset === this.caretPosition)) {
                        if (this.selectionStart.offset !== 0) {
                            this.selectionStart.offset--;
                        } else if (this.paragraphIndex !== 0) {
                            this.selectionStart.set(this.paragraphIndex - 1, this.textParagraphs[this.paragraphIndex - 1].length);
                        }
                    } else {
                        assert((this.selectionEnd.paragraphIndex === this.paragraphIndex) && (this.selectionEnd.offset === this.caretPosition));
                        if (this.selectionEnd.offset !== 0) {
                            this.selectionEnd.offset--;
                        } else if (this.paragraphIndex !== 0) {
                            this.selectionEnd.set(this.paragraphIndex - 1, this.textParagraphs[this.paragraphIndex - 1].length);
                        }
                    }
                }
                break;
            case this.CaretMovement.RIGHT:
                if (!this.selectionStart.isPositioned()) {
                    if (this.caretPosition !== this.currentParagraph().length) {
                        this.selectionStart.set(this.paragraphIndex, this.caretPosition);
                        this.selectionEnd.set(this.paragraphIndex, this.caretPosition + 1);
                    } else if (this.paragraphIndex < this.textParagraphs.length - 1) {
                        this.selectionStart.set(this.paragraphIndex, this.caretPosition);
                        this.selectionEnd.set(this.paragraphIndex + 1, 0);
                    }
                } else {
                    assert(this.selectionEnd.isPositioned());
                    if ((this.selectionStart.paragraphIndex === this.paragraphIndex)
                        && (this.selectionStart.offset === this.caretPosition)) {
                        if (this.selectionStart.offset !== this.currentParagraph().length) {
                            this.selectionStart.offset++;
                        } else {
                            assert(this.paragraphIndex < this.textParagraphs.length - 1, "selectionStart must not be positioned at the end of the document");
                            this.selectionStart.set(this.paragraphIndex + 1, 0);
                        }
                    } else {
                        assert((this.selectionEnd.paragraphIndex === this.paragraphIndex) && (this.selectionEnd.offset === this.caretPosition));
                        if (this.selectionEnd.offset !== this.currentParagraph().length) {
                            this.selectionEnd.offset++;
                        } else if (this.paragraphIndex < this.textParagraphs.length - 1) {
                            this.selectionEnd.set(this.paragraphIndex + 1, 0);
                        }
                    }
                }
                break;
            case this.CaretMovement.UP:
                break;
            case this.CaretMovement.DOWN:
                break;
            case this.CaretMovement.WORDLEFT:
                break;
            case this.CaretMovement.WORDRIGHT:
                break;
            case this.CaretMovement.HOME:
                if (!this.selectionStart.isPositioned()) {
                    this.selectionStart.set(this.paragraphIndex, 0);
                    this.selectionEnd.set(this.paragraphIndex, this.caretPosition);
                } else {
                    if (this.selectionStart.paragraphIndex === this.paragraphIndex) {
                        if (this.selectionStart.offset === this.caretPosition) {
                            this.selectionStart.set(this.paragraphIndex, 0);
                        } else {
                            assert(this.selectionEnd.offset === this.caretPosition, 
                                "If the caret is in the current paragraph, it must be at either start or end selection positions");
                            this.selectionEnd.set(this.paragraphIndex, this.selectionStart.offset);
                            this.selectionStart.set(this.paragraphIndex, 0);
                        }
                    }

                }
                break;
            case this.CaretMovement.END:
                break;

            default:
                assert(false, "Invalid caret movement");
        }

        if (this.selectionStart.equals(this.selectionEnd)) {
            this.clearSelection();
        }
    }

    clearSelection() {
        this.selectionStart.unposition();
        this.selectionEnd.unposition();
    }

    moveCaret(movement, shift) {
        if (shift) {
            this.updateSelection(movement);
        } else {
            this.clearSelection();
        }

        switch (movement) {
            case this.CaretMovement.LEFT:
                if (this.caretPosition > 0) {
                    this.caretPosition--;
                } else {
                    assert(this.caretPosition === 0, "Caret position must be 0 or positive");
                    if (this.paragraphIndex > 0) {
                        this.paragraphIndex--;
                        this.caretPosition = this.currentParagraph().length;
                    }
                }
                this.desiredCaretPosition = this.caretPosition;
                break;
            case this.CaretMovement.RIGHT:
                if (this.caretPosition < this.currentParagraph().length) {
                    this.caretPosition++;
                } else {
                    assert(this.caretPosition === this.currentParagraph().length, "Caret position must be less or equal to current paragraph length");
                    if (this.paragraphIndex < this.textParagraphs.length - 1) {
                        this.paragraphIndex++;
                        this.caretPosition = 0;
                    }
                }
                this.desiredCaretPosition = this.caretPosition;
                break;
            case this.CaretMovement.UP:
                if (this.paragraphIndex > 0) {
                    this.paragraphIndex--;
                    this.caretPosition = Math.min(this.currentParagraph().length, this.desiredCaretPosition);
                }
                break;
            case this.CaretMovement.DOWN:
                if (this.paragraphIndex < this.textParagraphs.length - 1) {
                    this.paragraphIndex++;
                    this.caretPosition = Math.min(this.currentParagraph().length, this.desiredCaretPosition);
                }
                break;
            case this.CaretMovement.WORDLEFT:
                break;
            case this.CaretMovement.WORDRIGHT:
                break;
            case this.CaretMovement.HOME:
                this.caretPosition = 0;
                this.desiredCaretPosition = this.caretPosition;
                break;
            case this.CaretMovement.END:
                this.caretPosition = this.currentParagraph().length;
                this.desiredCaretPosition = this.caretPosition;
                break;

            default:
                assert(false, "Invalid caret movement");
        }
    }

    backspace(shift, control) {
        if (this.caretPosition !== 0) {
            this.currentParagraph().splice(this.caretPosition - 1, 1);
            this.caretPosition--;
            this.desiredCaretPosition = this.caretPosition;
        } else if (this.paragraphIndex !== 0) {
            let currentParagraph = this.currentParagraph();
            let endOfPrevParagraph = this.textParagraphs[this.paragraphIndex - 1].length;
            this.textParagraphs.splice(this.paragraphIndex, 1);
            this.paragraphIndex--;
            this.textParagraphs[this.paragraphIndex] = this.currentParagraph().concat(currentParagraph);

            this.caretPosition = endOfPrevParagraph;
            this.desiredCaretPosition = this.caretPosition;
        }

    }

    delete(shift, control) {
        if (this.caretPosition !== this.currentParagraph().length) {
            this.currentParagraph().splice(this.caretPosition, 1);
        } else if (this.paragraphIndex < this.textParagraphs.length - 1) {
            let nextParagraph = this.textParagraphs[this.paragraphIndex + 1];
            this.textParagraphs.splice(this.paragraphIndex + 1, 1);
            this.textParagraphs[this.paragraphIndex] = this.currentParagraph().concat(nextParagraph);
        }
    }

    addParagraph() {
        // Add a new paragraph at paragraph index + 1
        let currentParagraph = this.currentParagraph();
        let tailCurrentParagraph = currentParagraph.splice(this.caretPosition, currentParagraph.length);

        this.paragraphIndex++;
        this.caretPosition = 0;
        this.desiredCaretPosition = this.caretPosition;
        this.textParagraphs.splice(this.paragraphIndex, 0, tailCurrentParagraph);
    }
}

class EditController {
    constructor(editContext, model, view) {
        this.editContext = editContext;
        this.model = model;
        this.view = view;
        this.controlPressed = false;

        editContext.addEventListener("focus", (e => {
            console.log("focus");
            this.view.focus();
        }).bind(this));

        editContext.addEventListener("blur", (e => {
            console.log("blur");
            this.view.blur();
        }).bind(this));

        editContext.addEventListener("keydown", e => {
            console.log(`keydown: ${e.key}`)
            switch (e.key) {
                case "ArrowLeft":
                    this.model.moveCaret(this.model.CaretMovement.LEFT, this.shiftPressed);
                    this.view.queueUpdate();
                    break;
                case "ArrowRight":
                    this.model.moveCaret(this.model.CaretMovement.RIGHT, this.shiftPressed);
                    this.view.queueUpdate();
                    break;
                case "ArrowUp":
                    this.model.moveCaret(this.model.CaretMovement.UP, this.shiftPressed);
                    this.view.queueUpdate();
                    break;
                case "ArrowDown":
                    this.model.moveCaret(this.model.CaretMovement.DOWN, this.shiftPressed);
                    this.view.queueUpdate();
                    break;
                case "Home":
                    this.model.moveCaret(this.model.CaretMovement.HOME, this.shiftPressed);
                    this.view.queueUpdate();
                    break;
                case "End":
                    this.model.moveCaret(this.model.CaretMovement.END, this.shiftPressed);
                    this.view.queueUpdate();
                    break;
                case "Enter":
                    this.model.addParagraph();
                    this.view.queueUpdate();
                    break;
                case "Backspace":
                    this.model.backspace(this.shiftPressed, this.controlPressed);
                    this.view.queueUpdate();
                    break;
                case "Delete":
                    this.model.delete(this.shiftPressed, this.controlPressed);
                    this.view.queueUpdate();
                    break;
                case "Control":
                    this.controlPressed = true;
                    break;
                case "Shift":
                    this.shiftPressed = true;
                    break;
            }
        });
        editContext.addEventListener("keyup", e => {
            console.log(`keyup: ${e.key}`)
            switch (e.key) {
                case "Control":
                    this.controlPressed = false;
                    break;
                case "Shift":
                    this.shiftPressed = false;
                    break;
            }
        });

        editContext.addEventListener("textupdating", (e => {
            console.log("textupdating: " + e.value)
            this.model.updateText(e.value);
            this.view.queueUpdate();
        }).bind(this));

        editContext.addEventListener("textrequested", e => { console.log("textrequested") });
        editContext.addEventListener("selectionrequested", e => { console.log("selectionrequested") });
        editContext.addEventListener("selectionupdating", e => { console.log("selectionupdating") });
        editContext.addEventListener("compositionstarted", e => { console.log("compositionstarted") });
        editContext.addEventListener("compositioncompleted", e => { console.log("compositioncompleted") });
        editContext.addEventListener("formatupdating", e => { console.log("formatupdating") });
        editContext.addEventListener("focusremoved", e => { console.log("focusremoved") });
        editContext.addEventListener("layoutrequested", e => { console.log("layoutrequested") });
    }
    
    moveLeft() {
        this.model.setCaretPosition(this.model.getCaretPosition() - 1);
        this.view.queueUpdate();
    }
}

window.addEventListener("load", () => {
    let editContext = new EditContext();
    let model = new EditModel(editContext);
    let view = new EditableView(editContext, model);
    let controller = new EditController(editContext, model, view);
    
    editContext.focus();
    // Render the initial view, so that you see the first blinking caret
    view.queueUpdate();
})
</script>
<body>
<p> This is an editable region, based on EditContext: </p>
<div id="editableviewholder" style="width:300px; height:300px; border:blue 1px dashed"></div>
<p> Some footer where other content might live </p>

