<html>
<head>
<style>
#realinputcontext {
    position:absolute;
    top:20px;
    right:20px;
}
#editview {
    white-space:pre
}

.selection {
    background:blue;
    color:white;
}
.caret {
    outline: 1px solid black;
}
</style>
<script src="editcontext.js"></script>
<script>

function assert(condition, message) {
    if (!condition) {
        throw message;
    }
}

class EditableView {
    constructor(editContext, editModel) {
        this.editContext = editContext;
        this.editModel = editModel;

        this.caret = document.createElement('span');
        this.caretOn = true;
        this.caretInterval = -1;
        this.caret.style = "outline:1px solid black";

        this.viewElement = document.createElement('code');
        this.viewElement.appendChild(this.caret);
        this.viewElement.style = "position:relative; white-space:pre; width:300px; height:300px";

        // TODO: Belong on controller?
        this.viewElement.addEventListener("mouseup", (function () {
            console.log("view got mouseup");
            this.editContext.focus();
        }).bind(this));

        editableviewholder.appendChild(this.viewElement);

        this.updateCaret();

        this.updateQueued = false;

        this.caretRange = document.createRange();
    }

    queueUpdate() {
        if (!this.updateQueued) {
            window.requestAnimationFrame((() => {
                this.updateView();

                // Turn caret on while the view is actively being updated
                this.caretOn = true;
                this.updateQueued = false;
            }).bind(this));
            this.updateQueued = true;
        }
    }

    updateView() {
        let html = this.editModel.asHtml();
        if (html !== "") {
            this.viewElement.innerHTML = html;
        } else {
            this.viewElement.innerHTML = "";
            this.viewElement.appendChild(this.caret);
        }
    }

    updateCaret() {
        if (this.editContext.hasFocus()) {
            this.caret.style.visibility = this.caretOn ? "visible" : "hidden";
            this.caretOn = !this.caretOn;
            if (this.caretInterval === -1) {
                const CARET_UPDATE_MS = 500;
                this.caretInterval = window.setInterval((() => this.updateCaret()).bind(this), CARET_UPDATE_MS);
            }
        } else if (this.caretInterval !== -1) {
            this.caret.style.visibility = "hidden";
            window.clearInterval(this.caretInterval);
            this.caretInterval = -1;
        }
    }
    focus() {
        this.caretOn = true;
        this.updateCaret();
    }

    blur() {
        this.updateCaret();
    }
}

class Position {
    constructor(x) {
        x = (x !== undefined) ? x : -1;
        this.set(x);
    }

    unposition() {
        this.set(-1);
    }

    isPositioned() {
        return (this.x !== -1);
    }

    equals(other) {
        assert(other.__proto__ === Position.prototype, "Can only test equality against another Position object");
        return this.x === other.x;
    }

    assign(other) {
        assert(other.__proto__ === Position.prototype, "Can only assign positions to another Position object");
        this.x = other.x;
    }

    set(x) {
        assert(typeof x === "number", "Position.x must be a number");
        assert(x !== NaN, "Position.x must not be NaN");
        this.x = x;
    }
}

class Selection {
    constructor() {
        this.anchor = new Position();
        this.focus = new Position();
    }

    unposition() {
        this.anchor.unposition();
        this.focus.unposition();
    }

    isEmpty() {
        return this.anchor.equals(this.focus);
    }

    isPositioned() {
        return this.anchor.isPositioned();
    }

    ensureSelection(x) {
        if (!this.anchor.isPositioned()) {
            this.anchor.set(x);
            this.focus.set(x);
        }
    }

    // start() and end() are based on document position, and doesn't provide
    // information about the anchor or focus.
    start() {
        if (this.anchor.isPositioned()) {
            return (this.focus.x < this.anchor.x) ? this.focus : this.anchor;
        } else {
            return null;
        }
    }

    end() {
        let startPosition = this.start();
        if (startPosition === null) {
            return null;
        }
        return startPosition === this.anchor ? this.focus : this.anchor;
    }
}

class EditModel {
    constructor(editContext) {
        this.text = [];
        this.caretPosition = new Position(0);
        this.desiredCaretX = 0;

        this.selection = new Selection();

        this.CaretMovement = { LEFT:0, RIGHT:1, WORDLEFT:2, WORDRIGHT:3, HOME:4, END:5, UP: 6, DOWN: 7};
    }

    asHtml() {
        let html = "";
        let selectionStart = this.selection.start();
        selectionStart = (selectionStart) ? selectionStart.x : -1;
        let selectionEnd = this.selection.end();
        selectionEnd = (selectionEnd) ? selectionEnd.x : -1;
        this.text.forEach((character, index) => {
            let offsetRealized = 0;
            if (this.caretPosition.x === index) {
                html += "<span class='caret'></span>";
            }

            if (selectionStart === index) {
                html += "<span class='selection'>";
            }

            if (character !== "\n") {
                html += character;
            } else {
                html += "<br>";
            }

            if (selectionEnd - 1 === index) {
                html += "</span>";
            }
        })

        if (this.caretPosition.x === this.text.length) {
            html += "<span class='caret'></span>";
        }

        return html;
    }

    updateText(text, start, end) {
        if (start === end) {
            let insertPosition = start;
            for (let i = 0; i < text.length; i++) {
                this.text.splice(insertPosition, 0, text.charAt(i));
                insertPosition++;
            }
            assert(insertPosition === start + text.length, "We must have inserted text.length characters");
            this.caretPosition.set(start + text.length);
        }
        this.updateDesirectCaretColumn();
    }

    updateDesirectCaretColumn() {
        this.desiredCaretX = this.getCurrentCaretColumn()
        assert(this.desiredCaretX >= 0, "desired caret column must be >= 0");
    }

    getCurrentCaretColumn() {
        return this.caretPosition.x - this.getCurrentRowBeginIndex();
    }
    
    getCurrentRowBeginIndex() {
        return this.text.lastIndexOf("\n", this.caretPosition.x - 1) + 1;
    }

    getCaretPosition() {
        return this.caretPosition;
    }

    movePosition(position, movement) {
        switch (movement) {
            case this.CaretMovement.LEFT:
                if (position.x !== 0) {
                    position.set(position.x - 1);
                }
                break;
            case this.CaretMovement.RIGHT:
                if (position.x !== this.text.length) {
                    position.set(position.x + 1);
                }
                break;
            case this.CaretMovement.UP:
                let rowBegin = this.text.lastIndexOf("\n", position.x - 1);
                if (rowBegin !== -1 && rowBegin !== 0) {
                    let previousRowBegin = this.text.lastIndexOf("\n", rowBegin - 1);
                    if (previousRowBegin === -1) {
                        previousRowBegin = 0;
                    }

                    let previousRowLength = rowBegin - previousRowBegin;
                    position.set(previousRowBegin + Math.min(this.desiredCaretX, previousRowLength));
                }
                break;
            case this.CaretMovement.DOWN:
                let nextNewline = this.text.indexOf("\n", this.caretPosition.x);
                if (nextNewline !== -1) {
                    let nextRowBegin = nextNewline + 1;
                    let nextNextNewline = this.text.indexOf("\n", nextRowBegin);
                    let nextRowEnd = nextNextNewline === -1 ? this.text.length : nextNextNewline;
                    let nextRowLength = nextRowEnd - nextRowBegin;
                    position.set(nextRowBegin + Math.min(this.desiredCaretX, nextRowLength));
                }
                break;
            case this.CaretMovement.WORDLEFT:
                break;
            case this.CaretMovement.WORDRIGHT:
                break;
            case this.CaretMovement.HOME:
                let rowBeginIndex = this.text.lastIndexOf("\n", position.x - 1);
                if (rowBeginIndex === -1) {
                    rowBeginIndex = 0;
                }
                position.set(rowBeginIndex);
                break;
            case this.CaretMovement.END:
                let nextNewLine = this.text.indexOf("\n", position.x);
                let endRow = nextNewLine === -1 ? this.text.length : nextNewLine;
                position.set(endRow);
                break;

            default:
                assert(false, "Invalid position movement");
        }

    }

    isHorizontalMovement(movement) {
        return movement === this.CaretMovement.LEFT ||
            movement === this.CaretMovement.RIGHT ||
            movement === this.CaretMovement.HOME ||
            movement === this.CaretMovement.END;
    }

    updateSelection(movement) {
        this.selection.ensureSelection(this.caretPosition.x);
        this.movePosition(this.selection.focus, movement);

        if (this.selection.isEmpty()) {
            this.clearSelection();
        }
    }

    clearSelection() {
        this.selection.unposition();
    }

    moveCaret(movement, shift) {
        if (shift) {
            this.updateSelection(movement);
            this.movePosition(this.caretPosition, movement);
        } else {
            if (this.selection.anchor.isPositioned()) {
                this.clearSelection();
            }
            this.movePosition(this.caretPosition, movement);
        }

        if (this.isHorizontalMovement(movement)) {
            this.updateDesirectCaretColumn();
        }
    }

    backspace(shift, control) {
        if (!this.selection.isPositioned()) {
            if (this.caretPosition.x !== 0) {
                this.text.splice(this.caretPosition.x - 1, 1);
                this.caretPosition.x--;
                this.updateDesirectCaretColumn();
            }
        } else {
            this.replaceSelection("");
            this.caretPosition.assign(this.selection.start());
            this.clearSelection();
        }
    }

    delete(shift, control) {
        if (!this.selection.isPositioned()) {
            if (!shift) {
                this.text.splice(this.caretPosition.x, 1);
            } else {
                // TODO: Implement shift-delete remove line
            }
        } else {
            this.replaceSelection("");
            this.caretPosition.assign(this.selection.start());
            this.clearSelection();
        }
    }

    replaceSelection(replacementText) {
        let start = this.selection.start();
        let end = this.selection.end();
        this.text.splice(start.x, end.x - start.x);
    }

    addRow() {
        this.updateText("\n", this.caretPosition.x, this.caretPosition.x);
        this.desiredCaretX = 0;
    }
}

class EditController {
    constructor(editContext, model, view) {
        this.editContext = editContext;
        this.model = model;
        this.view = view;
        this.controlPressed = false;

        editContext.addEventListener("focus", (e => {
            console.log("focus");
            this.view.focus();
        }).bind(this));

        editContext.addEventListener("blur", (e => {
            console.log("blur");
            this.view.blur();
        }).bind(this));

        editContext.addEventListener("keydown", e => {
            console.log(`keydown: ${e.key}`)
            switch (e.key) {
                case "ArrowLeft":
                    this.model.moveCaret(this.model.CaretMovement.LEFT, this.shiftPressed);
                    this.view.queueUpdate();
                    break;
                case "ArrowRight":
                    this.model.moveCaret(this.model.CaretMovement.RIGHT, this.shiftPressed);
                    this.view.queueUpdate();
                    break;
                case "ArrowUp":
                    this.model.moveCaret(this.model.CaretMovement.UP, this.shiftPressed);
                    this.view.queueUpdate();
                    break;
                case "ArrowDown":
                    this.model.moveCaret(this.model.CaretMovement.DOWN, this.shiftPressed);
                    this.view.queueUpdate();
                    break;
                case "Home":
                    this.model.moveCaret(this.model.CaretMovement.HOME, this.shiftPressed);
                    this.view.queueUpdate();
                    break;
                case "End":
                    this.model.moveCaret(this.model.CaretMovement.END, this.shiftPressed);
                    this.view.queueUpdate();
                    break;
                case "Enter":
                    this.model.addRow();
                    this.view.queueUpdate();
                    break;
                case "Backspace":
                    this.model.backspace(this.shiftPressed, this.controlPressed);
                    this.view.queueUpdate();
                    break;
                case "Delete":
                    this.model.delete(this.shiftPressed, this.controlPressed);
                    this.view.queueUpdate();
                    break;
                case "Control":
                    this.controlPressed = true;
                    break;
                case "Shift":
                    this.shiftPressed = true;
                    break;
            }
        });

        editContext.addEventListener("keyup", e => {
            console.log(`keyup: ${e.key}`)
            switch (e.key) {
                case "Control":
                    this.controlPressed = false;
                    break;
                case "Shift":
                    this.shiftPressed = false;
                    break;
            }
        });

        editContext.addEventListener("textupdating", (e => {
            console.log("textupdating: " + e.value)
            this.model.updateText(e.text, e.start, e.end);
            this.view.queueUpdate();
        }).bind(this));

        editContext.addEventListener("textrequested", e => { console.log("textrequested") });
        editContext.addEventListener("selectionrequested", e => { console.log("selectionrequested") });
        editContext.addEventListener("selectionupdating", e => { console.log("selectionupdating") });
        editContext.addEventListener("compositionstarted", e => { console.log("compositionstarted") });
        editContext.addEventListener("compositioncompleted", e => { console.log("compositioncompleted") });
        editContext.addEventListener("formatupdating", e => { console.log("formatupdating") });
        editContext.addEventListener("focusremoved", e => { console.log("focusremoved") });
        editContext.addEventListener("layoutrequested", e => { console.log("layoutrequested") });
    }
}

window.addEventListener("load", () => {
    let editContext = new EditContext();
    let model = new EditModel(editContext);
    let view = new EditableView(editContext, model);
    let controller = new EditController(editContext, model, view);
    
    editContext.focus();
    // Render the initial view, so that you see the first blinking caret
    view.queueUpdate();
})
</script>
<body>
<p> This is an editable region, based on EditContext: </p>
<div id="editableviewholder" style="width:300px; height:300px; border:blue 1px dashed"></div>
<p> Some footer where other content might live </p>

